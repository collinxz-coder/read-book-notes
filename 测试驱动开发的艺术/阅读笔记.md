## 测试选择

衡量以下四组情况来选择更合适的测试：
1. 深入细节与整体考虑
2. 探索未知与轻车熟路
3. 最大限度获取价值与摘取现成的果实
4. 走通基本功能路径(happy path)与先处理出错情况

测试的选择并没有一个标准的答案，应该结合项目实际情况来对以上四点进行不同的组合。不过，总体上来说，先从简单的测试入手是一个好主意。

## 实现测试的方式
1. 伪实现：为了尽快将测试状态从“红”变成“绿”，使用伪实现可能是最为快捷的方式了，例如直接硬编码。
2. 三角法：利用三角法有效的缩减解空间，以达到尽可能清楚硬编码的目的。
3. 显而易见的实现： 相对显而易见的方法，我们可以不必像使用三角法或者伪实现那么谨小慎微。而是直接编写实现代码。

## 测试驱动的基本原则

1. 别跳过重构：很多开发者往往记住了`测试`及`编码`阶段，却很容易忽略那些需要重构的代码坏味道。
2. 尽快变绿：尽快从“红”的状态中脱离出来
3. 出错后放慢脚步：当出现错误时，我们应该意识到我们的步乏已经太大以至于超出了理解范围，这个时候应该到饮水机那边弄杯水和，休息休息，将步伐放慢下来。

## 一些重要的概念

### 夹具

夹具是测试的上下文，它包含了测试类中所有测试方法共有的一些初始条件（整个运行时的状态：产品和测试代码中的静态变量、加载类时静态初始化块中创建的各种对象等）。

我们应该以对待产品代码的态度来对待测试代码，所以保证测试代码的质量也至关重要，利用夹具可以有效的消除测试代码中的重复，将所有测试中的重复提取到一处。当然光板夹具(clean slate fixture)是一个绝对要避免的反模式。

夹具还能使测试代码变得更为经凑，测试代码只关注真正要测试的东西。利用好夹具能改使我们的测试代码变得干净和经凑。

### 测试替身

在测试中，通常被测对象与其它对象之间存在协助，或者存在依赖关系。这些依赖关系有时候会非常难处理，例如 `java.sql.ResultSet` 对象等。这个时候就需要使用测试替身来替代真实的对象。

选择测试替身的几种原因：
1. 太慢
2. 目前尚不存在
3. 其依赖的东西并不存在
4. 很难实例化，为测试配置状态也不容易

| Mock 类型 | 描述 |
| --- | --- |
| 测试桩 | 给定接口最为简单的实现。通常返回硬编码、无意义的值 |
| 伪实现 | 较之测试桩，伪实现更为复杂，通常可以认为是接口的另一种实现。换言之，虽然伪实现不是鸭子，但是其外形和行走方式都与鸭子一致。相比之下测试桩只是看起来像鸭子而已 |
| 模拟对象 | 从实现角度而言，最为复杂。模拟对象可以验证待测对象与其协作对象的交互。由于具体实现方式不同，有些模拟对象可以返回硬编码值，而有些能改提供逻辑的伪实现。模拟对象通常由框架或者类库动态产生，不过也可以手动实现 |

### 提高设计的可测试行的准则
1. 使用组合而不是继承
2. 尽量避免使用 static 关键字，以及 Singleton 模式
3. 隔离依赖
4. 注入依赖

### 单元测试模式

#### 断言模式

1. 结果状态验证：先调用功能，然后验证其内部状态与期望状态是否一致
2. 防卫断言：用来明确的验证调用功能前对夹具所做的各种假设。防卫断言经常与结果状态断言一同使用，先验证调用前的状态，然后执行功能，再对结果进行验证。
3. 差值断言：在控制权不完全在自己手中的代码基础上进行工作，这个时候可能无法在夹具中硬编码，所以我们需要先记录下状态，然后执行功能后将新状态与保存的旧状态做对比以验证差值是否正确。
4. 自定义断言：对复杂的断言进行封装，提取出自定义断言。
5. 交互断言：不验证代码结果的正确性而是验证代码与其它对象的交互行为的正确性。

